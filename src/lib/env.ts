import fs from 'fs'
import path from 'path'
import dotenv from 'dotenv'

const ENV_FILE = '.env'
const GITIGNORE_FILE = '.gitignore'

export interface CabalEnv {
  CABAL_API_KEY?: string
  CABAL_AGENT_NAME?: string
  CABAL_API_URL?: string
}

// Legacy keys to clean up from old CLI versions
const LEGACY_KEYS = [
  'CABAL_AGENT_ID',
  'SOLANA_PUBLIC_KEY',
  'SOLANA_PRIVATE_KEY',
  'EVM_PUBLIC_KEY',
  'EVM_PRIVATE_KEY',
]

/**
 * Load existing .env file
 */
export function loadEnv(): CabalEnv {
  const envPath = path.resolve(process.cwd(), ENV_FILE)

  if (fs.existsSync(envPath)) {
    const result = dotenv.config({ path: envPath })
    return (result.parsed || {}) as CabalEnv
  }

  return {}
}

/**
 * Check if Cabal is already configured
 */
export function isConfigured(): boolean {
  const env = loadEnv()
  return !!env.CABAL_API_KEY
}

/**
 * Save credentials to .env file
 */
export function saveEnv(credentials: {
  apiKey: string
  agentName: string
  apiUrl?: string
}): void {
  const envPath = path.resolve(process.cwd(), ENV_FILE)

  // Load existing env to preserve other variables
  let existingContent = ''
  if (fs.existsSync(envPath)) {
    existingContent = fs.readFileSync(envPath, 'utf-8')

    // Remove old Cabal-related lines (current + legacy)
    const cabalKeys = [
      'CABAL_API_KEY',
      'CABAL_AGENT_NAME',
      'CABAL_API_URL',
      ...LEGACY_KEYS,
    ]

    const lines = existingContent.split('\n').filter(line => {
      const key = line.split('=')[0]?.trim()
      return !cabalKeys.includes(key)
    })

    existingContent = lines.join('\n').trim()
    if (existingContent) existingContent += '\n\n'
  }

  // Build new Cabal section
  let cabalSection = `# Cabal Agent Credentials
# Generated by cabal-cli â€” do not share!
CABAL_API_KEY=${credentials.apiKey}
CABAL_AGENT_NAME=${credentials.agentName}
`

  if (credentials.apiUrl) {
    cabalSection += `CABAL_API_URL=${credentials.apiUrl}\n`
  }

  fs.writeFileSync(envPath, existingContent + cabalSection)
}

/**
 * Get credentials from env
 */
export function getCredentials(): CabalEnv {
  // First try process.env (for already loaded vars)
  const fromProcess: CabalEnv = {
    CABAL_API_KEY: process.env.CABAL_API_KEY,
    CABAL_AGENT_NAME: process.env.CABAL_AGENT_NAME,
    CABAL_API_URL: process.env.CABAL_API_URL,
  }

  // Then try loading from .env file
  const fromFile = loadEnv()

  return { ...fromFile, ...fromProcess }
}

/**
 * Check if .env is in .gitignore
 */
export function isEnvInGitignore(): boolean {
  const gitignorePath = path.resolve(process.cwd(), GITIGNORE_FILE)

  if (!fs.existsSync(gitignorePath)) {
    return false
  }

  const content = fs.readFileSync(gitignorePath, 'utf-8')
  const lines = content.split('\n').map(line => line.trim())

  // Check for common .env patterns
  return lines.some(line =>
    line === '.env' ||
    line === '.env*' ||
    line === '.env.local' ||
    line === '*.env' ||
    line.startsWith('.env')
  )
}

/**
 * Add .env to .gitignore if it exists
 */
export function ensureEnvInGitignore(): { added: boolean; created: boolean } {
  const gitignorePath = path.resolve(process.cwd(), GITIGNORE_FILE)

  if (!fs.existsSync(gitignorePath)) {
    // Create .gitignore with .env
    fs.writeFileSync(gitignorePath, '.env\n')
    return { added: true, created: true }
  }

  if (isEnvInGitignore()) {
    return { added: false, created: false }
  }

  // Append .env to existing .gitignore
  const content = fs.readFileSync(gitignorePath, 'utf-8')
  const newContent = content.endsWith('\n') ? `${content}.env\n` : `${content}\n.env\n`
  fs.writeFileSync(gitignorePath, newContent)

  return { added: true, created: false }
}
