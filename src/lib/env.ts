import fs from 'fs'
import path from 'path'
import dotenv from 'dotenv'

const ENV_FILE = '.env'
const GITIGNORE_FILE = '.gitignore'

export interface CabalEnv {
  CABAL_API_KEY?: string
  CABAL_AGENT_ID?: string
  CABAL_AGENT_NAME?: string
  SOLANA_PUBLIC_KEY?: string
  SOLANA_PRIVATE_KEY?: string
  EVM_PUBLIC_KEY?: string
  EVM_PRIVATE_KEY?: string
}

/**
 * Load existing .env file
 */
export function loadEnv(): CabalEnv {
  const envPath = path.resolve(process.cwd(), ENV_FILE)

  if (fs.existsSync(envPath)) {
    const result = dotenv.config({ path: envPath })
    return (result.parsed || {}) as CabalEnv
  }

  return {}
}

/**
 * Check if Cabal is already configured
 */
export function isConfigured(): boolean {
  const env = loadEnv()
  return !!env.CABAL_API_KEY
}

/**
 * Save credentials to .env file
 */
export function saveEnv(credentials: {
  apiKey: string
  agentId: string
  agentName: string
  solanaPublicKey?: string
  solanaPrivateKey?: string
  evmPublicKey?: string
  evmPrivateKey?: string
}): void {
  const envPath = path.resolve(process.cwd(), ENV_FILE)

  // Load existing env to preserve other variables
  let existingContent = ''
  if (fs.existsSync(envPath)) {
    existingContent = fs.readFileSync(envPath, 'utf-8')

    // Remove old Cabal-related lines
    const cabalKeys = [
      'CABAL_API_KEY',
      'CABAL_AGENT_ID',
      'CABAL_AGENT_NAME',
      'SOLANA_PUBLIC_KEY',
      'SOLANA_PRIVATE_KEY',
      'EVM_PUBLIC_KEY',
      'EVM_PRIVATE_KEY',
    ]

    const lines = existingContent.split('\n').filter(line => {
      const key = line.split('=')[0]?.trim()
      return !cabalKeys.includes(key)
    })

    existingContent = lines.join('\n').trim()
    if (existingContent) existingContent += '\n\n'
  }

  // Build new Cabal section
  let cabalSection = `# Cabal Agent Credentials
# Generated by cabal-cli - DO NOT SHARE THESE!
CABAL_API_KEY=${credentials.apiKey}
CABAL_AGENT_ID=${credentials.agentId}
CABAL_AGENT_NAME=${credentials.agentName}
`

  if (credentials.solanaPublicKey && credentials.solanaPrivateKey) {
    cabalSection += `
# Solana Wallet (for Jupiter swaps on Solana)
SOLANA_PUBLIC_KEY=${credentials.solanaPublicKey}
SOLANA_PRIVATE_KEY=${credentials.solanaPrivateKey}
`
  }

  if (credentials.evmPublicKey && credentials.evmPrivateKey) {
    cabalSection += `
# EVM Wallet (for Hyperliquid perps/spot)
EVM_PUBLIC_KEY=${credentials.evmPublicKey}
EVM_PRIVATE_KEY=${credentials.evmPrivateKey}
`
  }

  fs.writeFileSync(envPath, existingContent + cabalSection)
}

/**
 * Get credentials from env
 */
export function getCredentials(): CabalEnv {
  // First try process.env (for already loaded vars)
  const fromProcess: CabalEnv = {
    CABAL_API_KEY: process.env.CABAL_API_KEY,
    CABAL_AGENT_ID: process.env.CABAL_AGENT_ID,
    CABAL_AGENT_NAME: process.env.CABAL_AGENT_NAME,
    SOLANA_PUBLIC_KEY: process.env.SOLANA_PUBLIC_KEY,
    SOLANA_PRIVATE_KEY: process.env.SOLANA_PRIVATE_KEY,
    EVM_PUBLIC_KEY: process.env.EVM_PUBLIC_KEY,
    EVM_PRIVATE_KEY: process.env.EVM_PRIVATE_KEY,
  }

  // Then try loading from .env file
  const fromFile = loadEnv()

  return { ...fromFile, ...fromProcess }
}

/**
 * Check if .env is in .gitignore
 */
export function isEnvInGitignore(): boolean {
  const gitignorePath = path.resolve(process.cwd(), GITIGNORE_FILE)

  if (!fs.existsSync(gitignorePath)) {
    return false
  }

  const content = fs.readFileSync(gitignorePath, 'utf-8')
  const lines = content.split('\n').map(line => line.trim())

  // Check for common .env patterns
  return lines.some(line =>
    line === '.env' ||
    line === '.env*' ||
    line === '.env.local' ||
    line === '*.env' ||
    line.startsWith('.env')
  )
}

/**
 * Add .env to .gitignore if it exists
 */
export function ensureEnvInGitignore(): { added: boolean; created: boolean } {
  const gitignorePath = path.resolve(process.cwd(), GITIGNORE_FILE)

  if (!fs.existsSync(gitignorePath)) {
    // Create .gitignore with .env
    fs.writeFileSync(gitignorePath, '.env\n')
    return { added: true, created: true }
  }

  if (isEnvInGitignore()) {
    return { added: false, created: false }
  }

  // Append .env to existing .gitignore
  const content = fs.readFileSync(gitignorePath, 'utf-8')
  const newContent = content.endsWith('\n') ? `${content}.env\n` : `${content}\n.env\n`
  fs.writeFileSync(gitignorePath, newContent)

  return { added: true, created: false }
}
